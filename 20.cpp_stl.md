## 1、Vector扩容，什么情况1.5倍，什么情况2倍？

vector 在插入新的元素时但是之前的内存已经满的时候需要扩容，在VS下是1.5倍，在GCC 下是2 倍。



## 2、Vector的resize和reserve有什么区别？

1. **resize**: `resize(n)`会改变vector的大小，使其包含n个元素。如果n大于当前的大小，那么新的元素会被添加到vector的末尾，如果n小于当前的大小，那么末尾的元素会被删除。`resize`会改变vector的`size()`。
2. **reserve**: `reserve(n)`不会改变vector的大小，它只是预先分配足够的内存，以便在未来可以容纳n个元素。`reserve`不会改变vector的`size()`，但可能会改变`capacity()`。`reserve`的主要目的是为了优化性能，避免在添加元素时频繁进行内存分配。

简单来说，`resize`改变的是vector中元素的数量，而`reserve`改变的是vector的内存容量。



## 3、vector中push_back和emplace_back的区别？

emplace_back通常在性能上优于push_back，因为它可以避免不必要的复制或移动操作。

- push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）
- 而emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。





## 4、Map，set，unordered_map，unordered_set，底层是用了什么数据结构？

1. **Map**: 底层实现通常是红黑树，这是一种自平衡的二叉查找树。它可以保证插入、删除和查找的时间复杂度都是O(log n)。
2. **Set**: 与Map类似，Set的底层实现通常也是红黑树。Set是一种特殊的Map，只有键没有值。
3. **Unordered_map**: 底层实现通常是哈希表。哈希表可以提供平均时间复杂度为O(1)的查找。
4. **Unordered_set**: 与Unordered_map类似，Unordered_set的底层实现通常也是哈希表。Unordered_set是一种特殊的Unordered_map，只有键没有值。





