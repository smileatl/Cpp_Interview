# cpp_智能指针

## 3、智能指针的原理、常用的智能指针及实现

### **原理**

智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源

### **常用的智能指针**

#### **(1) shared_ptr**

实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。

- 智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针
- 每次创建类的新对象时，初始化指针并将引用计数置为1
- 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数
- 对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数
- 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）

#### **(2) unique_ptr**

unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。

#### **(3) weak_ptr**

weak_ptr：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。

#### **(4) auto_ptr**

主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。

auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。

auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。

### **智能指针shared_ptr代码实现：**

```cpp
template<typename T>
class SharedPtr
{
public:
	SharedPtr(T* ptr = NULL):_ptr(ptr), _pcount(new int(1))
	{}

	SharedPtr(const SharedPtr& s):_ptr(s._ptr), _pcount(s._pcount){
		(*_pcount)++;
	}

	SharedPtr<T>& operator=(const SharedPtr& s){
		if (this != &s)
		{
			if (--(*(this->_pcount)) == 0)
			{
				delete this->_ptr;
				delete this->_pcount;
			}
			_ptr = s._ptr;
			_pcount = s._pcount;
			(*_pcount)++;
		}
		return *this;
	}
	T& operator*()
	{
		return *(this->_ptr);
	}
	T* operator->()
	{
		return this->_ptr;
	}
	~SharedPtr()
	{
		--(*(this->_pcount));
		if (*(this->_pcount) == 0)
		{
			delete _ptr;
			_ptr = NULL;
			delete _pcount;
			_pcount = NULL;
		}
	}
private:
	T* _ptr;
	int* _pcount;//指向引用计数的指针
};
```



## 4、智能指针的原理

智能指针是C++中用于管理动态分配资源的一种机制，它是一个类，用来存储指向动态分配对象的指针（封装一个原始指针），负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。

智能指针的主要原理是利用了RAII（Resource Acquisition Is Initialization）的概念，即资源获取即初始化。



## 5、手写一个shared_ptr

### 首先回顾一下shared_ptr的概念

- `shared_ptr` 内部维护了一个引用计数器，记录有多少个 `shared_ptr` 共享同一块内存资源。每当创建一个新的 `shared_ptr` 对象指向该资源时，引用计数就加一；当 `shared_ptr` 对象被销毁或者重新赋值时，引用计数就减一。只有当引用计数变为零时，表示没有任何 `shared_ptr` 指向该资源，内存才会被释放。
- shared_ptr将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；
- 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；
- 对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；
- 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则自动删除所指向的堆内存）。

### 智能指针shared_ptr代码实现

```cpp
template<typename T>
class SharedPtr
{
public:
    // 默认构造函数，创建一个空的 SharedPtr 对象。
    explicit SharedPtr(); 
    // 接受一个原始指针 _ptr，创建一个包装该指针的 SharedPtr 对象
    explicit SharedPtr(T *_ptr); 
    // 拷贝构造函数，用于初始化一个新的 SharedPtr 对象，与另一个 SharedPtr 共享所管理的对象。
    SharedPtr(const SharedPtr& p); 
    // 析构函数，负责释放所管理的对象，并递减计数器。当计数器为零时，表示没有任何 SharedPtr 对象引用该对象，可以安全删除。
    ~SharedPtr();

    // 重载拷贝赋值运算符，用于将另一个 SharedPtr 的状态赋值给当前对象。
    // 在赋值之前，会先递减当前对象的计数器，并根据需要释放资源。
    // 然后将另一个 SharedPtr 的指针和计数器赋值给当前对象。
    SharedPtr& operator=(const SharedPtr& p);

    // 重载解引用运算符，返回所管理对象的引用。
    T& operator*();
    // 重载箭头运算符，返回所管理对象的指针。
    T* operator->();
    // 重载布尔值操作
    operator bool();

    // 返回所管理的原始指针。
    T* get() const;

    // 返回当前共享所管理对象的 SharedPtr 数量。
    size_t use_count();

    // 检查是否只有一个 SharedPtr 引用该对象
    bool unique();

    // 交换两个 SharedPtr 对象之间的资源和状态
    void swap(SharedPtr& p);

private:
    size_t *count;
    T *ptr;
};

template<typename T>
SharedPtr<T>::SharedPtr() : count(new size_t(0)), ptr(nullptr)
{}

template<typename T>
SharedPtr<T>::SharedPtr(T *_ptr) : count(new size_t(1)), ptr(_ptr)
{}

template<typename T>
SharedPtr<T>::~SharedPtr()
{
    --(*count);
    if(*count <= 0) {
        delete ptr;
        delete count;
        ptr = nullptr;
        count = nullptr;
    }
    std::cout << "shared ptr destory." << std::endl;
}

template<typename T>
SharedPtr<T>::SharedPtr(const SharedPtr &p)
{
    count = p.count;
    ptr = p.ptr;
    ++(*count);
}

template<typename T>
SharedPtr<T>& SharedPtr<T>::operator=(const SharedPtr &p)
{
    // 如果是原指针，直接返回
    if(ptr == p.ptr) {
        return *this;
    }

    if(ptr) {
        --(*count);
        if((*count) == 0) {
            delete ptr;
            delete count;
        }
    }

    ptr = p.ptr;
    count = p.count;
    ++(*count);
    return *this;
}

template<typename T>
T& SharedPtr<T>::operator*()
{
    return *ptr;
}

template<typename T>
T* SharedPtr<T>::operator->()
{
    return ptr;
}

template<typename T>
SharedPtr<T>::operator bool()
{
    return ptr != nullptr;
}

template<typename T>
T* SharedPtr<T>::get() const
{
    return ptr;
}

template<typename T>
size_t SharedPtr<T>::use_count()
{
    return *count;
}

template<typename T>
bool SharedPtr<T>::unique()
{
    return *count == 1;
}

template<typename T>
void SharedPtr<T>::swap(SharedPtr& p)
{
    std::swap(*this, p);
}
```



### 为什么shared_ptr赋值时，左边引用计数减一，右边引用计数加一

在 `shared_ptr` 赋值时，左边引用计数减一，右边引用计数加一的原因是为了维护资源的正确引用计数。

当一个 `shared_ptr` 对象赋值给另一个 `shared_ptr` 对象时，目标对象（左边）可能已经指向了其他资源。在进行赋值操作之前，我们希望递减左边对象的引用计数，以避免资源的过早释放。

然后，我们将右边对象的资源和引用计数复制到左边对象中。递增右边对象的引用计数是因为赋值操作后，左右两个对象都指向了同一块资源，需要确保引用计数的正确性。

这样做的好处是，在赋值完成后，左右两个 `shared_ptr` 对象都可以独立地管理资源，并且其引用计数也能正确地反映出资源被引用的次数。同时，如果左边对象的引用计数减少到零，则表示没有任何对象引用该资源，可以安全地释放资源。

这种引用计数的机制使得多个 `shared_ptr` 对象能够共享同一个资源，并自动在最后一个引用对象销毁时，释放内存。但是需要注意避免循环引用的情况，即两个或多个 `shared_ptr` 对象相互引用导致无法释放资源的问题。



## 6、手写实现智能指针类需要实现哪些函数？

1、智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录SmartPointer<T*>对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象。

除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。

通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1

2、一个构造函数、拷贝构造函数、赋值构造函数、析构函数、移动函数；



## 7、智能指针shared_ptr出现循环引用怎么解决

弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个shared_ptr成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。

### 我的：

在C++中，当使用`std::shared_ptr`来管理资源时，循环引用（cyclic reference）可能会导致资源无法释放，从而造成内存泄漏。循环引用指的是两个或多个对象彼此持有对方的`std::shared_ptr`，从而导致资源无法被正确释放。

为了解决`std::shared_ptr`循环引用问题，可以采用以下几种方法：

**1. 使用std::weak_ptr：** `std::weak_ptr`是`std::shared_ptr`的一种弱引用，它不会增加所指对象的引用计数，也不拥有所指对象。通过将其中一个`std::shared_ptr`转换为`std::weak_ptr`来打破循环引用。

```
cpp复制代码class ClassB; // 前向声明

class ClassA {
    std::shared_ptr<ClassB> ptrB;
};

class ClassB {
    std::weak_ptr<ClassA> weakPtrA;
};
```

使用`std::weak_ptr`可以避免循环引用导致资源无法释放，但在使用`std::weak_ptr`时需要注意判断其是否过期（expired），可以通过调用`std::weak_ptr`的`lock()`函数获取一个有效的`std::shared_ptr`，然后再进行操作。

### chatgpt：

`std::weak_ptr`可以解决循环引用问题是因为它不会增加所指对象的引用计数，也不拥有所指对象。相比之下，`std::shared_ptr`会增加引用计数，只有当引用计数变为零时，才会释放资源。

通过将其中一个`std::shared_ptr`转换为`std::weak_ptr`，可以打破循环引用，从而避免资源无法正确释放的问题。当存在循环引用时，即使没有其他外部引用，`std::shared_ptr`之间仍然互相持有对方的引用，导致引用计数不为零，资源无法被释放。

而`std::weak_ptr`的特点在于，它可以观测到所指对象是否已经被销毁（expired），并且可以通过调用`lock()`函数生成一个有效的`std::shared_ptr`来使用这个对象。如果所指对象已经销毁，则`lock()`函数返回一个空的`std::shared_ptr`。

使用`std::weak_ptr`作为解决循环引用的机制，可以让其中一个对象持有另一个对象的弱引用，这样在析构时不会增加引用计数，从而允许引用计数变为零，从而释放资源。通过手动调用`lock()`函数来获取一个有效的`std::shared_ptr`，可以确保对象在使用期间不会被提前销毁。

总结起来，`std::weak_ptr`通过不增加引用计数的方式来解决循环引用问题，从而避免资源无法正确释放，并提供了一种安全地观测所指对象是否已销毁的机制。







## 8、强弱智能指针

- **强智能指针**：资源每被强智能指针引用一次，引用计数+1，释放引用计数-1，如shared_ptr;
- **弱智能指针**：仅仅起到观察作用，观察对象释放还存在，不改变资源的引用计数，如weak_ptr.





## 12、boost::scope_ptr智能指针（使用及原理分析）

 boost::scoped_ptr是一个比较简单的智能指针，它能保证在**离开作用域**之后它所管理对象能被**自动释放**。下面这个例子将介绍它的使用：

```cpp
 1 #include <iostream>
 2 #include <boost/scoped\_ptr.hpp>
 3 
 4 using namespace std; 5 
 6 class Book 7 {
 8 public:
 9 Book()
10 {
11         cout << "Creating book ..." << endl;
12 }
13 
14     ~Book()
15 {
16         cout << "Destroying book ..." << endl;
17 }
18 };
19 
20 int main()
21 {   
22     cout << "=====Main Begin=====" << endl;
23 {
24         boost::scoped\_ptr<Book> myBook(new Book());
25 }
26     cout << "===== Main End =====" << endl;
27 
28     return 0;
29 }
```

 运行结果：

![](assets/282053339505502.jpg)

 可以看出：当myBook离开了它的作用域之后，它所管理的Book对象也随之销毁。

**特点——不能共享控制权**

 scoped\_ptr不能通过其他scoped\_ptr共享控制权，因为在scoped\_ptr类的内部将**拷贝构造函数**和**\=运算符重载**定义为**私有的**。我们看下scoped\_ptr类的定义就清楚了：

```cpp
namespace boost
{
    // 声明一个模板类 scoped_ptr，继承 noncopyable，用于管理指针资源
    template<typename T> class scoped_ptr : noncopyable
    {
    private:
        T *px; // 指向被管理的对象的指针

        // 复制构造函数和赋值操作符被私有化，禁止拷贝和赋值
        scoped_ptr(scoped_ptr const &);
        scoped_ptr &operator=(scoped_ptr const &);

        typedef scoped_ptr<T> this_type;

        void operator==( scoped_ptr const & ) const; // 禁用比较操作符==
        void operator!=( scoped_ptr const & ) const; // 禁用比较操作符!=
    public:
        // 构造函数：接受指针参数，并创建 scoped_ptr 实例
        explicit scoped_ptr(T *p = 0);
        // 析构函数：释放指针指向的对象资源
        ~scoped_ptr();

        // 构造函数：接受 std::auto_ptr 参数，并创建 scoped_ptr 实例
        explicit scoped_ptr( std::auto_ptr<T> p ): px( p.release() );
        // 重置指针指向的对象
        void reset(T *p = 0);

        // 解引用操作符：返回指针指向的对象的引用
        T &operator*() const;
        // 成员访问操作符：返回指针指向的对象的指针
        T *operator->() const;
        // 获取内部的指针
        T *get() const;

        // 交换两个 scoped_ptr 实例的指针
        void swap(scoped_ptr &b);
    };

    // 交换两个 scoped_ptr 实例的指针
    template<typename T>
    void swap(scoped_ptr<T> &a, scoped_ptr<T> &b);
}

```

 下面这段代码中的注释部分打开会造成编译失败：

```cpp
#include <iostream>
#include <boost/scoped_ptr.hpp>

using namespace std;

class Book
{
public:
    Book()
    {
        cout << "Creating book ..." << endl;
    }

    ~Book()
    {
        cout << "Destroying book ..." << endl;
    }
};

int main()
{
    cout << "=====Main Begin=====" << endl;
    {
        boost::scoped_ptr<Book> myBook(new Book());
        //boost::scoped_ptr<Book> myBook1(myBook);    // Error: scoped_ptr的拷贝构造函数私有
        //boost::scoped_ptr<Book> myBook2 = myBook;   // Error: scoped_ptr的=运算符重载私有
    }
    cout << "===== Main End =====" << endl;

    return 0;
}
```

所以，scoped\_ptr不能用在标准库的容器中，因为容器中的push\_back操作需要调用scoped\_ptr的=运算符重载函数，结果就是会导致编译失败。

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <boost/scoped_ptr.hpp>

using namespace std;

class Book
{
private:
    string name_;

public:
    Book(string name) : name_(name)
    {
        cout << "Creating book " << name_ << " ..." << endl;
    }

    ~Book()
    {
        cout << "Destroying book " << name_ << " ..." << endl;
    }
};

int main()
{
    cout << "=====Main Begin=====" << endl;
    {
        boost::scoped_ptr<Book> myBook(new Book("「1984」"));
        vector<boost::scoped_ptr<Book>> vecScoped;
        //vecScoped.push_back(myBook);   // Error: push_back操作内部调用了scoped_ptr的=运算符重载函数
    }
    cout << "===== Main End =====" << endl;

    return 0;
}
```

**编译检查=万无一失？**

 虽然我们无法通过scoped\_ptr的拷贝构造函数和=运算符重载函数共享控制权。那如果将一个对象交给多个scoped\_ptr来管理会怎样？

```cpp
#include <iostream>
#include <boost/scoped_ptr.hpp>

using namespace std;

class Book
{
public:
    Book()
    {
        cout << "Creating book ..." << endl;
    }

    ~Book()
    {
        cout << "Destroying book ..." << endl;
    }
};

int main()
{
    cout << "=====Main Begin=====" << endl;
    {
        Book * book = new Book();
        boost::scoped_ptr<Book> myBook(book);
        boost::scoped_ptr<Book> myBook1(book);
    }
    cout << "===== Main End =====" << endl;

    return 0;
}
```

  我们发现编译没报错，但是运行时出错了，如下：

![](assets/282136240968027.jpg)

     之所以会这样是因为每个scoped\_ptr对象都保存了自己所管理对象指针px，scoped\_ptr对象在离开自己作用域时会调用了自身的析构函数，在析构函数内部会调用delete px，当多个scoped\_ptr管理同一个对象时，那么在它们离开作用域之后，势必会多次调用delete以释放它们所管理的对象，从而造成程序运行出错。

**其他接口**

     虽然scoped\_ptr不能转移控制权，但是它们可以交换共享权。就以下面的代码举个例子：

```cpp
#include <iostream>
#include <string>
#include <boost/scoped_ptr.hpp>

using namespace std;

class Book
{
private:
    string name_;

public:
    Book(string name) : name_(name)
    {
        cout << "Creating book " << name_ << " ..." << endl;
    }

    ~Book()
    {
        cout << "Destroying book " << name_ << " ..." << endl;
    }
};

int main()
{
    cout << "=====Main Begin=====" << endl;
    {
        boost::scoped_ptr<Book> myBook(new Book("「1984」"));
        boost::scoped_ptr<Book> myBook1(new Book("「A Song of Ice and Fire」"));
        myBook.swap(myBook1);
    }
    cout << "===== Main End =====" << endl;

    return 0;
}
```

  运行结果：

![](assets/282204464504108.jpg)

 根据栈的特性，应该是后面构造的scoped\_ptr对象先销毁（从而销毁了它们所管理的对象），正是因为我们对两个智能指针的控制权进行交换之后，才出现了这种相反的结果。

 此外，在scoped\_ptr离开作用域之前也是可以显式销毁它们所管理的对象的。调用它的reset方法即可。请看下面例子：

```cpp
#include <iostream>
#include <string>
#include <boost/scoped_ptr.hpp>

using namespace std;

class Book
{
private:
    string name_;

public:
    Book(string name) : name_(name)
    {
        cout << "Creating book " << name_ << " ..." << endl;
    }

    ~Book()
    {
        cout << "Destroying book " << name_ << " ..." << endl;
    }
};

int main()
{
    cout << "=====Main Begin=====" << endl;
    {
        boost::scoped_ptr<Book> myBook(new Book("「1984」"));
        myBook.reset();
        cout << "After reset ..." << endl;
    }
    cout << "===== Main End =====" << endl;

    return 0;
}
```

  运行结果：

![](assets/282213039634535.jpg)

 可以看出：程序在输出“After reset ...”之前已经完成了对所管理对象的释放。

**总结（摘自《超越C++标准库：Boost库导论》）**

 使用裸指针来写异常安全和无错误的代码是很复杂的。使用智能指针来自动地把动态分配对象的生存期限制在一个明确的范围之内，是解决这种问题的一个有效的方法，并且提高了代码的可读性、可维护性和质量。scoped\_ptr明确地表示被指物不能被共享和转移。当一个动态分配的对象被传送给 scoped\_ptr, 它就成为了这个对象的唯一的拥有者。因为scoped\_ptr几乎总是以自动变量或数据成员来分配的，因此它可以在离开作用域时正确地销毁，从而在执行流由于返回语句或异常抛出而离开作用域时，总能释放它所管理的内存。

 在以下情况时使用scoped\_ptr：

*   在可能有异常抛出的作用域里使用指针
*   函数里有几条控制路径
*   动态分配对象的生存期应被限制于特定的作用域内
*   异常安全非常重要时(始终如此!)

**参考**

*   [http://www.cnblogs.com/sld666666/archive/2010/12/16/1908265.html](http://www.cnblogs.com/sld666666/archive/2010/12/16/1908265.html)
*   Björn Karlsson：Beyond the C++ Standard Library: An Introduction to Boost（《超越C++标准库：Boost库导论》）

（完）

本文转自 [https://www.cnblogs.com/helloamigo/p/3572533.html](https://www.cnblogs.com/helloamigo/p/3572533.html)，如有侵权，请联系删除。



13、