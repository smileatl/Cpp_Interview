# 操作系统-网络系统

## 1、如果同时有大量客户并发建立连接，服务器端有什么机制进行处理

两种方法：多线程同步阻塞和I/O多路复用socket的建立。

### 多线程同步阻塞

多线程同步阻塞是指在每个客户端连接到来时，都会创建一个新的线程来处理该连接，这样可以实现并发处理。

### I/O多路复用socket的建立

在一个线程中同时监听多个端口，当有新的连接请求到来时，该线程会将该连接请求分配给一个空闲的线程来处理。





## 2、IO多路复用

IO多路复用（I/O Multiplexing）是一种高效的I/O处理方式，它通过单线程或少量线程同时监听多个I/O事件，并在有事件发生时进行相应的处理。常见的IO多路复用技术包括select、poll和epoll。

IO多路复用的优势如下：

1. 单线程或少量线程可以同时处理多个I/O事件，极大地提高了系统的并发性能和吞吐量。

2. 相比于传统的阻塞式IO，IO多路复用可以避免阻塞式IO中线程因等待I/O而被浪费掉的时间，提高了CPU的利用率。

3. IO多路复用采用事件驱动模式，只有在I/O事件就绪时才会进行相应的操作，减少了不必要的系统调用次数，降低了系统开销。

4. IO多路复用可以同时监听多种类型的I/O事件，如读、写、异常等，具有更灵活的功能。

5. 适用于处理大量连接的场景，能够有效地管理和服务大规模的客户端请求。

需要注意的是，在使用IO多路复用时也需要考虑以下问题：

1. 对于长时间的I/O操作，仍然可能造成阻塞，影响其他事件的处理，需要进行合理的超时设置和错误处理。

2. 在使用select和poll时，需要维护一个存放I/O事件的数据结构，随着监听的文件描述符增多，效率可能会降低。

3. epoll是Linux下较为常用的IO多路复用机制，但并不跨平台，使用时需要注意兼容性问题。

总结：IO多路复用是一种高效的I/O处理方式，能够同时监听多个I/O事件并在事件就绪时进行相应处理，提高了系统的并发性能和吞吐量。它适用于大量连接、高并发的场景，可以提高服务器的性能和可扩展性。



## 3、select、poll和epoll

select、poll和epoll都是常见的IO多路复用机制，它们用于监听多个I/O事件并在事件就绪时进行相应处理，提高系统的并发性能和吞吐量。下面是对它们的简要介绍：

1. select：select 是最早出现的IO多路复用机制，可以同时监听多个文件描述符上的读、写和异常事件。使用 select 需要将所有待监听的文件描述符集合复制到内核空间，并通过调用 select 函数不断轮询检查是否有事件就绪。select 的缺点是每次调用 select 都需要将文件描述符集合从用户空间复制到内核空间，效率较低。

2. poll：poll 是对 select 的改进版本，在功能上类似于 select，但采用了基于链表的数据结构来存储待监听的文件描述符集合，避免了 select 中需要复制集合的问题。使用 poll 时，仍然需要不断轮询检查是否有事件就绪，但由于没有了集合复制的开销，相对于 select 来说效率稍高一些。

3. epoll：epoll 是 Linux 下的一种高性能 IO 多路复用机制，相比于 select 和 poll 具有更好的性能和扩展性。通过 epoll_ctl 函数注册需要监听的事件，将关注的文件描述符添加到内核事件表中，当事件就绪时，内核会主动通知应用程序。epoll 支持水平触发和边缘触发两种模式，能够有效地避免无效的事件通知，提高了性能。

总结：select、poll和epoll都是常见的IO多路复用机制，它们在监听多个I/O事件方面有相似的功能，但在性能和扩展性上有一定差异。select 是最早出现的，效率较低；poll 对 select 进行了改进，减少了集合复制的开销；epoll 是 Linux 下的高性能IO多路复用机制，具有较好的性能和扩展性。选择使用哪种机制应该根据实际需求和系统环境进行权衡和选择。



## 4、epoll水平触发和边缘触发的区别是什么

在使用 epoll I/O 多路复用机制时，可以选择水平触发（Level Triggered）或边缘触发（Edge Triggered）两种模式。它们之间的区别主要体现在对事件通知的触发方式和处理方式上：

1. 水平触发（Level Triggered）：
- 当一个文件描述符就绪时，epoll_wait 函数会立即返回，并将该文件描述符加入到已就绪的事件集合中。
- 应用程序需要循环调用 epoll_wait 来获取所有已就绪的事件，并进行相应的处理。
- 如果一个文件描述符上的数据没有全部读取完毕，在下一次 epoll_wait 调用时仍然会返回该文件描述符，表示该文件描述符上仍有数据可读。

2. 边缘触发（Edge Triggered）：
- 当一个文件描述符就绪时，epoll_wait 函数只会触发一次事件通知，并将该文件描述符加入到已就绪的事件集合中。
- 应用程序需要循环调用 epoll_wait 来获取所有已就绪的事件，并进行相应的处理。
- 如果一个文件描述符上的数据没有全部读取完毕，在下一次 epoll_wait 调用时不会再返回该文件描述符，除非有新的数据到达。

总结来说，水平触发会在文件描述符就绪时重复触发事件通知，而边缘触发只会触发一次事件通知。边缘触发需要应用程序自行确保将一个就绪的文件描述符上的数据全部读取完毕，以免遗漏未读取的数据。相对于水平触发，边缘触发具有更高的触发效率，但也要求应用程序更加细致地处理事件和数据的读写。选择使用哪种触发方式需要根据实际需求和系统特点进行权衡。





## 6、简述 socket 中 select 与 epoll 的使用场景以及区别，epoll 中水平触发以及边缘触发有什么不同？

> I/O多路复用中 select, poll, epoll之间有什么区别，各自支持的最大描述符上限以及原因是什么？

参考：

[Cyc2018-IO模型](http://www.cyc2018.xyz/计算机基础/Socket/Socket.html#一、i-o-模型)

[Cyc2018-IO复用](http://www.cyc2018.xyz/计算机基础/Socket/Socket.html#二、i-o-复用)





## 9、说说什么是大端小端，如何判断大端小端？

**小端模式**：**低的有效字节存储在低的存储器地址**。**小端一般为主机字节序**；常用的X86结构是小端模
式。很多的ARM，DSP都为小端模式。
**大端模式**：**高的有效字节存储在低的存储器地址**。**大端为网络字节序**；KEIL C51则为大端模式。



有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

如何判断：我们可以根据联合体来判断系统是大端还是小端。因为联合体变量总是从低地址存储。

```cpp
int fun1(){  
    union test{   
        char c;   
        int i; 
    };  
    test t; t.i = 1;  
    //如果是大端，则t.c为0x00，则t.c != 1，反之是小端  
    return (t.c == 1);  
} 
```



## 12、在进行网络通信时是否需要进行字节序转换？

相同字节序的平台在进行网络通信时可以不进行字节序转换，但是跨平台进行网络数据通信时必须进行字节序转换。

原因如下：

- 网络协议（大端字节序）规定接收到得第一个字节是高字节，存放到低地址，所以发送时会首先去低地址取数据的高字节。
- 小端模式的多字节数据在存放时，低地址存放的是低字节，而被发送方网络协议函数发送时会首先去低地址取数据（想要取高字节，真正取得是低字节），
- 接收方网络协议函数接收时会将接收到的第一个字节存放到低地址（想要接收高字节，真正接收的是低字节），所以最后双方都正确的收发了数据。
- 而相同平台进行通信时，如果双方都进行转换最后虽然能够正确收发数据，但是所做的转换是没有意义的，造成资源的浪费。
- 而不同平台进行通信时必须进行转换，不转换会造成错误的收发数据，字节序转换函数会根据当前平台的存储模式做出相应正确的转换，如果当前平台是大端，则直接返回不进行转换，如果当前平台是小端，会将接收到得网络字节序进行转换。

**网络字节序**

网络上传输的数据都是字节流,对于一个多字节数值,在进行网络传输的时候,先传递哪个字节?

也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有
意义的问题; 

UDP/TCP/IP协议规定: 把接收到的第一个字节当作高位字节看待, 这就要求发送端发送的第一个字节是高位字节; 而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);

由此可见,**多字节数值在发送之前,在内存中应该是以大端法存放的**; 所以说,网络字节序是大端字节序; 比如,我们经过网络发送整型数值0x12345678时,在80X86平台中,它是以小端发存放的,**在发送之前需要使用系统提供的字节序转换函数htonl()将其转换成大端法存放的数值;** 