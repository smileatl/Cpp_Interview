## 1、C++ 11有哪些新特性？

- **nullptr替代 NULL**
- **引入了 auto 和 decltype 这两个关键字实现了类型推导**
- **基于范围的 for 循环for(auto& i : res){}**
- **类和结构体的中初始化列表**
- **成员变量默认初始化**
- **右值引用和move语义**
- **智能指针**等

标准库的扩充（往STL里新加进一些模板类，比较好用）

- Lambda 表达式（匿名函数）
- std::forward_list（单向链表）
- 无序容器和正则表达式

### 答案解析

(1)为什么要有decltype
 因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，
甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。

 auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：

```cpp
auto varname = value;
decltype(exp) varname = value;
```

其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。

auto 根据"="右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量
的类型，跟"="右边的 value 没有关系。

 另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初
始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面
的形式：

```cpp
decltype(exp) varname;
```







## 2、说一说你了解的关于lambda函数的全部知识

1）利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；

2）每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。

所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。

3）lambda表达式的语法定义如下：

```
[capture] （parameters） mutable ->return-type {statement};
即 [捕获列表](参数)mutable -> 返回值 {函数体}
```

4）lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；



### 面试宝典
1. 定义
  lambda 匿名函数很简单，可以套用如下的语法格式：

  ```cpp
   [外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型
   {
   函数体;
   };
  ```

  其中各部分的含义分别为：
  a. **[外部变量访问方式说明符]** 
   [ ] 方括号**用于向编译器表明当前是一个 lambda 表达式，其不能被省略**。在方括号内部，可以
  注明当前 lambda 函数的函数体中可以使用**哪些“外部变量”** 。
   所谓**外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量**。
  b.  **(参数)** 
   和普通函数的定义一样，lambda 匿名函数也可以**接收外部传递的多个参数**。和普通函数不同的
  是，如果不需要传递参数，可以连同 () 小括号一起省略；
  c. **mutable**
   此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。**默认情况**
  **下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解**
  **为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字**。
   注意:对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改
  真正的外部变量；
  d.  noexcept/throw()
   可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。**默认情况下，**
  **lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不**
  **会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型**。

  e.  -> **返回值类型**
   指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只**有一个 return** 
  **语句，或者该函数返回 void，则编译器可以自行推断出返回值类型**，此情况下可以直接省略"-> 返
  回值类型"。
  f. **函数体**
   和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使
  用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    int num[4] = {4, 2, 3, 1};
    //对 a 数组中的元素进行排序
    sort(num, num+4, [=](int x, int y) -> bool{ return x < y; } );
    for(int n : num){
        cout << n << " ";
    }
    return 0;
}

/*    
    程序运行结果：
        1 2 3 4
*/  
```




### 我的

简单的示例，展示了如何使用 C++ lambda：

```cpp
cpp复制代码#include <iostream>

int main() {
    int x = 5;
    int y = 10;

    // 使用 lambda 表达式定义一个匿名函数对象
    auto sum = [](int a, int b) -> int {
        return a + b;
    };

    // 调用 lambda 表达式
    int result = sum(x, y);

    std::cout << "Sum: " << result << std::endl;

    return 0;
}
```

在上面的示例中，我们定义了一个 lambda 表达式 `sum`，它接受两个整数参数并返回它们的和。然后，我们通过传入变量 `x` 和 `y`，调用这个 lambda 表达式，并将结果存储在 `result` 变量中。最后，我们将结果打印到控制台。



下面是一个示例，展示了一个 lambda 表达式具有捕获列表、参数和返回值的情况：

```cpp
#include <iostream>

int main() {
    int x = 5;
    int y = 10;

    // 使用捕获列表、参数和返回值的lambda表达式
    auto calculate = [x, &y](int a, int b) -> int {
        y++;  // 修改外部变量y的值

        return (x + a) * (y + b);
    };

    // 调用lambda表达式
    int result = calculate(2, 3);

    std::cout << "Result: " << result << std::endl;
    std::cout << "Updated y: " << y << std::endl;

    return 0;
}
```

在上述示例中，我们定义了一个 lambda 表达式 `calculate`，它具有一个捕获列表 `[x, &y]`，以及两个参数 `a` 和 `b`。该 lambda 表达式返回 `(x + a) * (y + b)` 的结果。

在 lambda 函数体内部，我们可以访问捕获的变量 `x`（通过值捕获）和 `y`（通过引用捕获）。我们还修改了外部变量 `y` 的值，这将影响后续的计算。

最后，在 `main` 函数中，我们调用了 lambda 表达式 `calculate`，传入参数 2 和 3，并将结果存储在 `result` 变量中。我们还打印了计算结果和修改后的变量 `y` 的值。

需要注意的是，lambda 表达式的参数列表和返回类型可以根据实际需求进行定义。在示例中，我们指定了两个整数类型的参数，并将返回值设定为整数类型。

总结来说，C++ lambda 表达式可以具有捕获列表、参数和返回值。通过指定捕获方式（值捕获或引用捕获）、参数列表和返回类型，我们可以定义一个灵活的匿名函数，并在其中访问和操作捕获的变量。



## 11、简述 C++ 右值引用与转移语义

右值引用 (Rvalue Referene) 是 C++11 新标准中引入的新特性 , 它实现了**转移语义** (Move Sementics) 和**精确传递** (Perfect Forwarding)。它的主要目的有两个方面：

- **消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率**
- **能够更简洁明确地定义泛型函数**

简单来说，就是右值引用是用来支持转移语义的，转移语义可以将资源（堆、系统对象等）从一个对象转移到另一个对象，**这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能**

在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。要实现转移语义，需要定义**转移构造函数**，还可以定义**转移赋值操作符**。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。**如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。**

> 标准库函数**move**可以将一个左值引用**强制转换**成右值引用来使用，相当于 static_cast
>
> 参考：
>
> - [[C++\]右值引用和转移语义_stary_yan的博客-CSDN博客](https://blog.csdn.net/stary_yan/article/details/51284929)
> - [C++ 移动构造函数详解](https://blog.csdn.net/weixin_44788542/article/details/126284429)



### 面试宝典



1. 右值引用
    一般来说，**不能取地址的表达式，就是右值引用，能取地址的，就是左值**。

  ```cpp
  class A { };
  A & r = A(); //error,A()是无名变量，是右值
  A && r = A(); //ok,r是右值引用
  ```

2. 转移语义
    move 本意为 "移动"，但该函数并不能移动任何数据，它的功能很简单，就是将**某个左值强制转**
   **化为右值**。基于 move() 函数特殊的功能，其常用于**实现移动语义**。



**答案解析**

1. **右值引用**
 C++98/03 标准中就有引用，使用 "&" 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 
C++ 中的左值，无法对右值添加引用。举个例子：

```cpp
int num = 10;
int &b = num; //正确
int &c = 10; //错误
```

如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，
C++98/03 标准中的引用又称为左值引用。

 注意：虽然 C++98/03 标准不支持为右值建立非常量左值引用，但**允许使用常量左值引用操作右值。**
**也就是说，常量左值引用既可以操作左值，也可以操作右值，例如**：

```cpp
int num = 10;
const int &b = num;
const int &c = 10;
```

我们知道，**右值往往是没有名称的，因此要使用它只能借助引用的方式**。这就产生一个问题，实际开
发中我们**可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的**。

 为此，C++11 标准新引入了另一种引用方式，称为**右值引用，用 "&&" 表示**。

 **注意**：和声明左值引用一样，**右值引用也必须立即进行初始化操作，且只能使用右值进行初始化**，比
如：

```cpp
int num = 10;
//int && a = num;  //右值引用不能初始化为左值
int && a = 10;  //右值引用初始化为右值
```

和常量左值引用不同的是，**右值引用还可以对右值进行修改**。例如：

```cpp
int && a = 10;
a = 100;
cout << a << endl;
/*    程序运行结果：        
        100 
*/ 
```

 另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：

```cpp
const int&& a = 10;//编译器不会报错
```

但这种定义出来的右值引用并无实际用处。一方面，**右值引用主要用于移动语义和完美转发，其中前**
**者需要有修改右值的权限**；其次，**常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可**
**以交给常量左值引用完成**。

2. move语义

   ```cpp
   //程序实例
   #include <iostream>
   using namespace std;
   class first {
   public:
       first() :num(new int(0)) {
           cout << "construct!" << endl;
       }
       //移动构造函数
       first(first &&d) :num(d.num) {
           d.num = NULL;
           cout << "first move construct!" << endl;
       }
   public:    //这里应该是 private，使用 public 是为了更方便说明问题
       int *num;
   };
   class second {
   public:
       second() :fir() {}
       //用 first 类的移动构造函数初始化 fir
       second(second && sec) :fir(move(sec.fir)) {
           cout << "second move construct" << endl;
       }
   public:    //这里也应该是 private，使用 public 是为了更方便说明问题
       first fir;
   };
   int main() {
       second oth; //输出construct!，因为构造了一个first
       second oth2 = move(oth);
       //cout << *oth.fir.num << endl;   //程序报运行时错误
       return 0;
   }
   
   /*    
       程序运行结果：
       construct!
       first move construct!
       second move construct
   */  
   ```

   



## 14、右值与左值

### 右值

在C++中，右值（Rvalue）是表达式的一个属性。**一个右值表示可以被移动（Move）但不能被复制（Copy）的临时对象或字面量值**。

```
右值可以分为两类：
1. 纯右值（Pure Rvalue）：纯右值指的是临时对象、字面量值（如数字、字符串等）和某些运算表达式的结果。
2. 将亡值（Xvalue，eXpiring value）：将亡值是指即将被销毁的对象，但它的资源可以被移动到其他地方。通常，具有移动构造函数或移动赋值运算符的对象会创建将亡值。
```



### 左值

在C++中，左值（Lvalue）是表达式的一个属性。**一个左值表示可以被标识符引用的对象或表达式**。

左值的特点如下：

1. **左值具有内存地址，并且可以通过指针来访问**。
2. **左值可以出现在赋值操作符的左边或右边**。
3. **左值可以进行复制（Copy），因为它们可以被多次使用和修改**。

以下是一些示例，展示了左值的使用：

```cpp
#include <iostream>

int main() {
    int x = 5; // x 是一个左值
    int y = x; // x 是一个左值，y 是一个左值
    
    int* ptr = &x; // x 的地址可以获取，因此 x 是一个左值
    
    std::cout << "x: " << x << std::endl;
    std::cout << "y: " << y << std::endl;
    
    return 0;
}
```

在上面的示例中，`x` 和 `y` 都是左值。它们都具有可寻址的内存位置，可以通过指针来间接访问它们。

需要注意的是，虽然从字面上看，`x` 和 `y` 都是整数，但它们在语义上是不同的。`x` 是一个命名的对象，而 `y` 是通过将 `x` 的值复制给 `y` 而创建的新对象。

此外，左值还可以是表达式的结果，只要该表达式返回一个可被标识符引用的对象。例如，`a + b` 是一个左值，如果 `a` 和 `b` 都是左值。

总之，左值表示可以被引用、修改和复制的对象或表达式。它们在C++中起着重要的作用，例如进行赋值操作、传递参数等。





17、简述一下 C++ 11 中 auto 的具体用法 

 auto用于定义变量，编译器可以自动判断变量的类型。auto主要有以下几种用法：

1. auto的基本使用方法
（1）基本使用语法如下

```cpp
auto name = value; //name 是变量的名字，value 是变量的初始值
```

 注意：auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。或者说，C++ 中的变量必
须是有明确类型的，只是这个类型是由编译器自己推导出来的。

2. auto和 const 的结合使用 
    （1） auto 与 const 结合的用法
   a. 当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；
   b. 当类型为引用时，auto 的推导结果将保留表达式的 const 属性。
    （2）程序实例如下

  ```cpp
  int  x = 0;
  const  auto n = x;  //n 为 const int ，auto 被推导为 int
  auto f = n;      //f 为 const int，auto 被推导为 int（const 属性被抛弃）
  const auto &r1 = x;  //r1 为 const int& 类型，auto 被推导为 int
  auto &r2 = r1;  //r1 为 const int& 类型，auto 被推导为 const int 类型
  ```

3. 使用auto定义迭代器
   在使用 stl 容器的时候，需要使用迭代器来遍历容器里面的元素；**不同容器的迭代器有不同的类**
   **型，在定义迭代器时必须指明**。而迭代器的类型有时候比较复杂，请看下面的例子：





## 16、 简述一下 C++11 中的可变参数模板新特性 

 可变参数模板(variadic template)使得编程者**能够创建这样的模板函数和模板类**，即**可接受可变数量**
**的参数**。例如要编写一个函数，它可接受任意数量的参数，参数的类型只需是cout能显示的即可，并将
参数显示为用逗号分隔的列表。

```cpp
int n = 14;
double x = 2.71828;
std::string mr = "Mr.String objects!";
show_list(n, x);
show_list(x*x, '!', 7, mr); //这里的目标是定义show_list()

/*    
    运行结果：
    14, 2.71828
    7.38905， !, 7, Mr.String objects!
*/  
```

要创建可变参数模板，需要理解几个要点：
 （1）模板参数包（parameter pack）；
 （2）函数参数包；
 （3）展开（unpack）参数包；
 （4）递归。



## 44、C++的四种强制转换reinterpret_cast/const_cast/static_cast /dynamic_cast

### **reinterpret_cast**

```
reinterpret_cast<type-id> (expression)
```

type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。

### **const_cast**

```
const_cast<type_id> (expression)
```

该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：

- 常量指针被转化成非常量的指针，并且仍然指向原来的对象
- 常量引用被转换成非常量的引用，并且仍然指向原来的对象
- const_cast一般用于修改底指针。如const char *p形式



### static_cast \< type-id \> (expression)

该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：

- **用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换**
  - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
  - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的
- **用于基本数据类型之间的转换**，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
- **把空指针转换成目标类型的空指针**
- **把任何类型的表达式转换成void类型**

注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。

### **dynamic_cast**

有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全

```
dynamic_cast <type-id> (expression)
```

该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*

如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用

**dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）**

dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换

**在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的**

在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全

### 举个例子

```cpp
#include <bits/stdc++.h>
using namespace std;

class Base
{
public:
	Base() :b(1) {}
	virtual void fun() {};
	int b;
};

class Son : public Base
{
public:
	Son() :d(2) {}
	int d;
};

int main()
{
	int n = 97;

	//reinterpret_cast
	int *p = &n;
	//以下两者效果相同
	char *c = reinterpret_cast<char*> (p); 
	char *c2 =  (char*)(p);
	cout << "reinterpret_cast输出："<< *c2 << endl;
	//const_cast
	const int *p2 = &n;
	int *p3 = const_cast<int*>(p2);
	*p3 = 100;
	cout << "const_cast输出：" << *p3 << endl;
	
	Base* b1 = new Son;
	Base* b2 = new Base;

	//static_cast
	Son* s1 = static_cast<Son*>(b1); //同类型转换
	Son* s2 = static_cast<Son*>(b2); //下行转换，不安全
	cout << "static_cast输出："<< endl;
	cout << s1->d << endl;
	cout << s2->d << endl; //下行转换，原先父对象没有d成员，输出垃圾值

	//dynamic_cast
	Son* s3 = dynamic_cast<Son*>(b1); //同类型转换
	Son* s4 = dynamic_cast<Son*>(b2); //下行转换，安全
	cout << "dynamic_cast输出：" << endl;
	cout << s3->d << endl;
	if(s4 == nullptr)
		cout << "s4指针为nullptr" << endl;
	else
		cout << s4->d << endl;
	
	
	return 0;
}
//输出结果
//reinterpret_cast输出：a
//const_cast输出：100
//static_cast输出：
//2
//-33686019
//dynamic_cast输出：
//2
//s4指针为nullptr
```

从输出结果可以看出，在进行下行转换时，dynamic_cast安全的，如果下行转换不安全的话其会返回空指针，这样在进行操作的时候可以预先判断。而使用static_cast下行转换存在不安全的情况也可以转换成功，但是直接使用转换后的对象进行操作容易造成错误。







## 46、简述一下 C++11 中四种类型转换 

C++中四种类型转换分别为**const_cast、static_cast、dynamic_cast、reinterpret_cast**，四种转
换功能分别如下：

1. **const_cast**
 **将const变量转为非const**

2. **static_cast**
 最常用，可以用于**各种隐式转换，比如非const转const，static_cast可以用于类向上转换，但向**
**下转换能成功但是不安全**。

3. dynamic_cast
 只能用于含有虚函数的类转换，用于类向上和向下转换
 **向上转换：指子类向基类转换**。 
 **向下转换：指基类向子类转换**。
 这两种转换，子类包含父类，当父类转换成子类时可能出现非法内存访问的问题。

 dynamic_cast通过**判断变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转**
**换**。**dynamic_cast可以做类之间上下转换，转换的时候会进行类型检查，类型相等成功转换，类**
**型不等转换失败**。运用RTTI技术，RTTI是”Runtime Type Information”的缩写，意思是运行时类型
信息，它**提供了运行时确定对象类型的方法**。在c++层面主要体现在dynamic_cast和typeid，vs中
虚函数表的-1位置存放了指向type_info的指针，对于存在虚函数的类型，dynamic_cast和typeid
 都会去查询type_info。

 4. reinterpret_cast
     reinterpret_cast可以做任何类型的转换，不过不对转换结果保证，容易出问题。

注意：为什么不用C的强制转换：C的强制转换表面上看起来功能强大什么都能转，但是转换不够明
确，不能进行错误检查，容易出错。













