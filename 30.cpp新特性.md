## 1、C++ 11有哪些新特性？

- nullptr替代 NULL
- 引入了 auto 和 decltype 这两个关键字实现了类型推导
- 基于范围的 for 循环for(auto& i : res){}
- 类和结构体的中初始化列表
- Lambda 表达式（匿名函数）
- std::forward_list（单向链表）
- 右值引用和move语义
- 无序容器和正则表达式
- 成员变量默认初始化
- 智能指针等
- 

## 2、说一说你了解的关于lambda函数的全部知识

1）利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；

2）每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。

所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。

3）lambda表达式的语法定义如下：

```
[capture] （parameters） mutable ->return-type {statement};
即 [捕获列表](参数)mutable -&gt; 返回值 {函数体}
```

4）lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；

### 我的

简单的示例，展示了如何使用 C++ lambda：

```cpp
cpp复制代码#include <iostream>

int main() {
    int x = 5;
    int y = 10;

    // 使用 lambda 表达式定义一个匿名函数对象
    auto sum = [](int a, int b) -> int {
        return a + b;
    };

    // 调用 lambda 表达式
    int result = sum(x, y);

    std::cout << "Sum: " << result << std::endl;

    return 0;
}
```

在上面的示例中，我们定义了一个 lambda 表达式 `sum`，它接受两个整数参数并返回它们的和。然后，我们通过传入变量 `x` 和 `y`，调用这个 lambda 表达式，并将结果存储在 `result` 变量中。最后，我们将结果打印到控制台。

下面是一个示例，展示了一个 lambda 表达式具有捕获列表、参数和返回值的情况：

```cpp
#include <iostream>

int main() {
    int x = 5;
    int y = 10;

    // 使用捕获列表、参数和返回值的lambda表达式
    auto calculate = [x, &y](int a, int b) -> int {
        y++;  // 修改外部变量y的值

        return (x + a) * (y + b);
    };

    // 调用lambda表达式
    int result = calculate(2, 3);

    std::cout << "Result: " << result << std::endl;
    std::cout << "Updated y: " << y << std::endl;

    return 0;
}
```

在上述示例中，我们定义了一个 lambda 表达式 `calculate`，它具有一个捕获列表 `[x, &y]`，以及两个参数 `a` 和 `b`。该 lambda 表达式返回 `(x + a) * (y + b)` 的结果。

在 lambda 函数体内部，我们可以访问捕获的变量 `x`（通过值捕获）和 `y`（通过引用捕获）。我们还修改了外部变量 `y` 的值，这将影响后续的计算。

最后，在 `main` 函数中，我们调用了 lambda 表达式 `calculate`，传入参数 2 和 3，并将结果存储在 `result` 变量中。我们还打印了计算结果和修改后的变量 `y` 的值。

需要注意的是，lambda 表达式的参数列表和返回类型可以根据实际需求进行定义。在示例中，我们指定了两个整数类型的参数，并将返回值设定为整数类型。

总结来说，C++ lambda 表达式可以具有捕获列表、参数和返回值。通过指定捕获方式（值捕获或引用捕获）、参数列表和返回类型，我们可以定义一个灵活的匿名函数，并在其中访问和操作捕获的变量。



## 3、智能指针的原理、常用的智能指针及实现

### **原理**

智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源

### **常用的智能指针**

#### **(1) shared_ptr**

实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。

- 智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针
- 每次创建类的新对象时，初始化指针并将引用计数置为1
- 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数
- 对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数
- 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）

#### **(2) unique_ptr**

unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。

#### **(3) weak_ptr**

weak_ptr：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。

#### **(4) auto_ptr**

主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。

auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。

auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。

### **智能指针shared_ptr代码实现：**

```
template<typename T>
class SharedPtr
{
public:
	SharedPtr(T* ptr = NULL):_ptr(ptr), _pcount(new int(1))
	{}

	SharedPtr(const SharedPtr& s):_ptr(s._ptr), _pcount(s._pcount){
		(*_pcount)++;
	}

	SharedPtr<T>& operator=(const SharedPtr& s){
		if (this != &s)
		{
			if (--(*(this->_pcount)) == 0)
			{
				delete this->_ptr;
				delete this->_pcount;
			}
			_ptr = s._ptr;
			_pcount = s._pcount;
			(*_pcount)++;
		}
		return *this;
	}
	T& operator*()
	{
		return *(this->_ptr);
	}
	T* operator->()
	{
		return this->_ptr;
	}
	~SharedPtr()
	{
		--(*(this->_pcount));
		if (*(this->_pcount) == 0)
		{
			delete _ptr;
			_ptr = NULL;
			delete _pcount;
			_pcount = NULL;
		}
	}
private:
	T* _ptr;
	int* _pcount;//指向引用计数的指针
};
```



## 4、智能指针的原理

智能指针是C++中用于管理动态分配资源的一种机制，它是一个类，用来存储指向动态分配对象的指针（封装一个原始指针），负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。

智能指针的主要原理是利用了RAII（Resource Acquisition Is Initialization）的概念，即资源获取即初始化。



## 5、手写一个shared_ptr

### 首先回顾一下shared_ptr的概念

- `shared_ptr` 内部维护了一个引用计数器，记录有多少个 `shared_ptr` 共享同一块内存资源。每当创建一个新的 `shared_ptr` 对象指向该资源时，引用计数就加一；当 `shared_ptr` 对象被销毁或者重新赋值时，引用计数就减一。只有当引用计数变为零时，表示没有任何 `shared_ptr` 指向该资源，内存才会被释放。
- shared_ptr将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；
- 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；
- 对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；
- 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则自动删除所指向的堆内存）。

### 智能指针shared_ptr代码实现

```cpp
template<typename T>
class SharedPtr
{
public:
    // 默认构造函数，创建一个空的 SharedPtr 对象。
    explicit SharedPtr(); 
    // 接受一个原始指针 _ptr，创建一个包装该指针的 SharedPtr 对象
    explicit SharedPtr(T *_ptr); 
    // 拷贝构造函数，用于初始化一个新的 SharedPtr 对象，与另一个 SharedPtr 共享所管理的对象。
    SharedPtr(const SharedPtr& p); 
    // 析构函数，负责释放所管理的对象，并递减计数器。当计数器为零时，表示没有任何 SharedPtr 对象引用该对象，可以安全删除。
    ~SharedPtr();

    // 重载拷贝赋值运算符，用于将另一个 SharedPtr 的状态赋值给当前对象。
    // 在赋值之前，会先递减当前对象的计数器，并根据需要释放资源。
    // 然后将另一个 SharedPtr 的指针和计数器赋值给当前对象。
    SharedPtr& operator=(const SharedPtr& p);

    // 重载解引用运算符，返回所管理对象的引用。
    T& operator*();
    // 重载箭头运算符，返回所管理对象的指针。
    T* operator->();
    // 重载布尔值操作
    operator bool();

    // 返回所管理的原始指针。
    T* get() const;

    // 返回当前共享所管理对象的 SharedPtr 数量。
    size_t use_count();

    // 检查是否只有一个 SharedPtr 引用该对象
    bool unique();

    // 交换两个 SharedPtr 对象之间的资源和状态
    void swap(SharedPtr& p);

private:
    size_t *count;
    T *ptr;
};

template<typename T>
SharedPtr<T>::SharedPtr() : count(new size_t(0)), ptr(nullptr)
{}

template<typename T>
SharedPtr<T>::SharedPtr(T *_ptr) : count(new size_t(1)), ptr(_ptr)
{}

template<typename T>
SharedPtr<T>::~SharedPtr()
{
    --(*count);
    if(*count <= 0) {
        delete ptr;
        delete count;
        ptr = nullptr;
        count = nullptr;
    }
    std::cout << "shared ptr destory." << std::endl;
}

template<typename T>
SharedPtr<T>::SharedPtr(const SharedPtr &p)
{
    count = p.count;
    ptr = p.ptr;
    ++(*count);
}

template<typename T>
SharedPtr<T>& SharedPtr<T>::operator=(const SharedPtr &p)
{
    // 如果是原指针，直接返回
    if(ptr == p.ptr) {
        return *this;
    }

    if(ptr) {
        --(*count);
        if((*count) == 0) {
            delete ptr;
            delete count;
        }
    }

    ptr = p.ptr;
    count = p.count;
    ++(*count);
    return *this;
}

template<typename T>
T& SharedPtr<T>::operator*()
{
    return *ptr;
}

template<typename T>
T* SharedPtr<T>::operator->()
{
    return ptr;
}

template<typename T>
SharedPtr<T>::operator bool()
{
    return ptr != nullptr;
}

template<typename T>
T* SharedPtr<T>::get() const
{
    return ptr;
}

template<typename T>
size_t SharedPtr<T>::use_count()
{
    return *count;
}

template<typename T>
bool SharedPtr<T>::unique()
{
    return *count == 1;
}

template<typename T>
void SharedPtr<T>::swap(SharedPtr& p)
{
    std::swap(*this, p);
}
```



### 为什么shared_ptr赋值时，左边引用计数减一，右边引用计数加一

在 `shared_ptr` 赋值时，左边引用计数减一，右边引用计数加一的原因是为了维护资源的正确引用计数。

当一个 `shared_ptr` 对象赋值给另一个 `shared_ptr` 对象时，目标对象（左边）可能已经指向了其他资源。在进行赋值操作之前，我们希望递减左边对象的引用计数，以避免资源的过早释放。

然后，我们将右边对象的资源和引用计数复制到左边对象中。递增右边对象的引用计数是因为赋值操作后，左右两个对象都指向了同一块资源，需要确保引用计数的正确性。

这样做的好处是，在赋值完成后，左右两个 `shared_ptr` 对象都可以独立地管理资源，并且其引用计数也能正确地反映出资源被引用的次数。同时，如果左边对象的引用计数减少到零，则表示没有任何对象引用该资源，可以安全地释放资源。

这种引用计数的机制使得多个 `shared_ptr` 对象能够共享同一个资源，并自动在最后一个引用对象销毁时，释放内存。但是需要注意避免循环引用的情况，即两个或多个 `shared_ptr` 对象相互引用导致无法释放资源的问题。



## 6、手写实现智能指针类需要实现哪些函数？

1、智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录SmartPointer<T*>对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象。

除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。

通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1

2、一个构造函数、拷贝构造函数、赋值构造函数、析构函数、移动函数；



## 7、智能指针shared_ptr出现循环引用怎么解决

弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个shared_ptr成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。

### 我的：

在C++中，当使用`std::shared_ptr`来管理资源时，循环引用（cyclic reference）可能会导致资源无法释放，从而造成内存泄漏。循环引用指的是两个或多个对象彼此持有对方的`std::shared_ptr`，从而导致资源无法被正确释放。

为了解决`std::shared_ptr`循环引用问题，可以采用以下几种方法：

**1. 使用std::weak_ptr：** `std::weak_ptr`是`std::shared_ptr`的一种弱引用，它不会增加所指对象的引用计数，也不拥有所指对象。通过将其中一个`std::shared_ptr`转换为`std::weak_ptr`来打破循环引用。

```
cpp复制代码class ClassB; // 前向声明

class ClassA {
    std::shared_ptr<ClassB> ptrB;
};

class ClassB {
    std::weak_ptr<ClassA> weakPtrA;
};
```

使用`std::weak_ptr`可以避免循环引用导致资源无法释放，但在使用`std::weak_ptr`时需要注意判断其是否过期（expired），可以通过调用`std::weak_ptr`的`lock()`函数获取一个有效的`std::shared_ptr`，然后再进行操作。

### chatgpt：

`std::weak_ptr`可以解决循环引用问题是因为它不会增加所指对象的引用计数，也不拥有所指对象。相比之下，`std::shared_ptr`会增加引用计数，只有当引用计数变为零时，才会释放资源。

通过将其中一个`std::shared_ptr`转换为`std::weak_ptr`，可以打破循环引用，从而避免资源无法正确释放的问题。当存在循环引用时，即使没有其他外部引用，`std::shared_ptr`之间仍然互相持有对方的引用，导致引用计数不为零，资源无法被释放。

而`std::weak_ptr`的特点在于，它可以观测到所指对象是否已经被销毁（expired），并且可以通过调用`lock()`函数生成一个有效的`std::shared_ptr`来使用这个对象。如果所指对象已经销毁，则`lock()`函数返回一个空的`std::shared_ptr`。

使用`std::weak_ptr`作为解决循环引用的机制，可以让其中一个对象持有另一个对象的弱引用，这样在析构时不会增加引用计数，从而允许引用计数变为零，从而释放资源。通过手动调用`lock()`函数来获取一个有效的`std::shared_ptr`，可以确保对象在使用期间不会被提前销毁。

总结起来，`std::weak_ptr`通过不增加引用计数的方式来解决循环引用问题，从而避免资源无法正确释放，并提供了一种安全地观测所指对象是否已销毁的机制。







## 8、强弱智能指针

- **强智能指针**：资源每被强智能指针引用一次，引用计数+1，释放引用计数-1，如shared_ptr;
- **弱智能指针**：仅仅起到观察作用，观察对象释放还存在，不改变资源的引用计数，如weak_ptr.



