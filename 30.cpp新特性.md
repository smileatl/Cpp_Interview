## 1、C++ 11有哪些新特性？

- nullptr替代 NULL
- 引入了 auto 和 decltype 这两个关键字实现了类型推导
- 基于范围的 for 循环for(auto& i : res){}
- 类和结构体的中初始化列表
- Lambda 表达式（匿名函数）
- std::forward_list（单向链表）
- 右值引用和move语义
- 无序容器和正则表达式
- 成员变量默认初始化
- 智能指针等
- 

## 2、说一说你了解的关于lambda函数的全部知识

1）利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；

2）每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。

所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。

3）lambda表达式的语法定义如下：

```
[capture] （parameters） mutable ->return-type {statement};
即 [捕获列表](参数)mutable -> 返回值 {函数体}
```

4）lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；

### 我的

简单的示例，展示了如何使用 C++ lambda：

```cpp
cpp复制代码#include <iostream>

int main() {
    int x = 5;
    int y = 10;

    // 使用 lambda 表达式定义一个匿名函数对象
    auto sum = [](int a, int b) -> int {
        return a + b;
    };

    // 调用 lambda 表达式
    int result = sum(x, y);

    std::cout << "Sum: " << result << std::endl;

    return 0;
}
```

在上面的示例中，我们定义了一个 lambda 表达式 `sum`，它接受两个整数参数并返回它们的和。然后，我们通过传入变量 `x` 和 `y`，调用这个 lambda 表达式，并将结果存储在 `result` 变量中。最后，我们将结果打印到控制台。



下面是一个示例，展示了一个 lambda 表达式具有捕获列表、参数和返回值的情况：

```cpp
#include <iostream>

int main() {
    int x = 5;
    int y = 10;

    // 使用捕获列表、参数和返回值的lambda表达式
    auto calculate = [x, &y](int a, int b) -> int {
        y++;  // 修改外部变量y的值

        return (x + a) * (y + b);
    };

    // 调用lambda表达式
    int result = calculate(2, 3);

    std::cout << "Result: " << result << std::endl;
    std::cout << "Updated y: " << y << std::endl;

    return 0;
}
```

在上述示例中，我们定义了一个 lambda 表达式 `calculate`，它具有一个捕获列表 `[x, &y]`，以及两个参数 `a` 和 `b`。该 lambda 表达式返回 `(x + a) * (y + b)` 的结果。

在 lambda 函数体内部，我们可以访问捕获的变量 `x`（通过值捕获）和 `y`（通过引用捕获）。我们还修改了外部变量 `y` 的值，这将影响后续的计算。

最后，在 `main` 函数中，我们调用了 lambda 表达式 `calculate`，传入参数 2 和 3，并将结果存储在 `result` 变量中。我们还打印了计算结果和修改后的变量 `y` 的值。

需要注意的是，lambda 表达式的参数列表和返回类型可以根据实际需求进行定义。在示例中，我们指定了两个整数类型的参数，并将返回值设定为整数类型。

总结来说，C++ lambda 表达式可以具有捕获列表、参数和返回值。通过指定捕获方式（值捕获或引用捕获）、参数列表和返回类型，我们可以定义一个灵活的匿名函数，并在其中访问和操作捕获的变量。



## 11、简述 C++ 右值引用与转移语义

右值引用 (Rvalue Referene) 是 C++11 新标准中引入的新特性 , 它实现了**转移语义** (Move Sementics) 和**精确传递** (Perfect Forwarding)。它的主要目的有两个方面：

- **消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率**
- **能够更简洁明确地定义泛型函数**

简单来说，就是右值引用是用来支持转移语义的，转移语义可以将资源（堆、系统对象等）从一个对象转移到另一个对象，**这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能**

在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。要实现转移语义，需要定义**转移构造函数**，还可以定义**转移赋值操作符**。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。**如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。**

> 标准库函数**move**可以将一个左值引用**强制转换**成右值引用来使用，相当于 static_cast
>
> 参考：
>
> - [[C++\]右值引用和转移语义_stary_yan的博客-CSDN博客](https://blog.csdn.net/stary_yan/article/details/51284929)
> - [C++ 移动构造函数详解](https://blog.csdn.net/weixin_44788542/article/details/126284429)







