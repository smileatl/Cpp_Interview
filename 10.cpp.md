## 1、extern"C"的用法

为了能够**正确的在C++代码中调用C语言**的代码：在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++。

### 哪些情况下使用extern “C”

（1）C++代码中调用C语言代码；

（2）在C++中的头文件中使用；

（3）在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；

举个例子，C++中调用C代码：

```
#ifndef __MY_HANDLE_H__
#define __MY_HANDLE_H__

extern "C"{
    typedef unsigned int result_t;
    typedef void* my_handle_t;
    
    my_handle_t create_handle(const char* name);
    result_t operate_on_handle(my_handle_t handle);
    void close_handle(my_handle_t handle);
}
```

综上，总结出使用方法，**在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern "C"声明，在.c文件中包含了extern "C"时会出现编译语法错误。**

所以使用extern "C"全部都放在于cpp程序相关文件或其头文件中。

### 总结出如下形式

#### （1）C++调用C函数：

```
//xx.h
extern int add(...)

//xx.c
int add(){
    
}

//xx.cpp
extern "C" {
    #include "xx.h"
}
```

#### （2）C调用C++函数

```
//xx.h
extern "C"{
    int add();
}
//xx.cpp
int add(){    
}
//xx.c
extern int add();
```





## 2、你知道空类的大小是多少吗？

1. C++空类的大小不为0，不同编译器设置不一样，vs设置为1；
2. C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；
3. 带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；
4. C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。





## 3、构造函数一般不定义为虚函数的原因

（1）创建一个对象时需要确定对象的类型，而虚函数是在运行时动态确定其类型的。在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型

（2）虚函数的调用需要虚函数表指针vptr，而该指针存放在对象的内存空间中，若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表vtable地址用来调用虚构造函数了

（3）虚函数的作用在于通过父类的指针或者引用调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类或者引用去调用，因此就规定构造函数不能是虚函数

（4）析构函数一般都要声明为虚函数，这个应该是老生常谈了，这里不再赘述



## 4、为什么析构函数一般写成虚函数？

由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。

所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。

```cpp
#include <iostream>
using namespace std;

class Parent{
public:
	Parent(){
		cout << "Parent construct function"  << endl;
	};
	~Parent(){
		cout << "Parent destructor function" <<endl;
	}
};

class Son : public Parent{
public:
	Son(){
		cout << "Son construct function"  << endl;
	};
	~Son(){
		cout << "Son destructor function" <<endl;
	}
};

int main()
{
	Parent* p = new Son();
	delete p;
	p = NULL;
	return 0;
}
//运行结果：
//Parent construct function
//Son construct function
//Parent destructor function
```

将基类的析构函数声明为虚函数：

```cpp
#include <iostream>
using namespace std;

class Parent{
public:
	Parent(){
		cout << "Parent construct function"  << endl;
	};
	virtual ~Parent(){
		cout << "Parent destructor function" <<endl;
	}
};

class Son : public Parent{
public:
	Son(){
		cout << "Son construct function"  << endl;
	};
	~Son(){
		cout << "Son destructor function" <<endl;
	}
};

int main()
{
	Parent* p = new Son();
	delete p;
	p = NULL;
	return 0;
}
//运行结果：
//Parent construct function
//Son construct function
//Son destructor function
//Parent destructor function
```

但存在一种特例，在`CRTP`模板中，不应该将析构函数声明为虚函数，理论上所有的父类函数都不应
该声明为虚函数，因为这种继承方式，不需要虚函数表。



### 小林：

析构函数被设为虚函数主要是为了解决基类指针指向派生类对象时的资源释放问题。

如果我们有一个基类指针，它实际上指向一个派生类对象，当我们删除这个基类指针时，如果析构函数不是虚函数，那么就只会调用基类的析构函数，而不会调用派生类的析构函数。这可能会导致派生类对象的一些资源没有被正确释放，从而引发内存泄漏等问题。

如果我们将析构函数设置为虚函数，那么在删除基类指针时，会首先调用派生类的析构函数，然后再调用基类的析构函数，从而确保所有的资源都能被正确释放。



## 5、了解模板吗？可以实现一个特定类型的吗？

C++模板是一种对类型进行参数化的工具，通常有两种形式：函数模板和类模板。函数模板针对仅参数类型不同的函数；类模板针对仅数据成员和成员函数类型不同的类。使用模板的目的就是能够让程序员编写与类型无关的代码。

### 代码参考

```cpp
template <typename T>
T add(T a, T b) {
    return a + b;
}
```

### 特化

在C++中，可以使用特化来为特定类型提供特定的实现。例如，我们可以为某个特定类型定义一个函数模板，然后在该类型上特化该函数模板，以提供特定于该类型的实现。以满足特定需求或优化性能。

C++中有两种主要的特化形式：类模板特化和函数模板特化。

1. 类模板特化（Class Template Specialization）：
   类模板特化允许为特定类型提供独立于通用模板定义的实现。特化的语法如下所示：
   ```cpp
   template <typename T>
   class MyTemplate {
       // 通用模板实现
   };

   template <>
   class MyTemplate<int> {
       // int类型的特化实现
   };
   ```
   在上述示例中，`MyTemplate` 是一个通用的类模板，但通过 `template <>` 和类型 `int` 的特化声明，我们为 `int` 类型提供了特殊的实现逻辑。

2. 函数模板特化（Function Template Specialization）：
   函数模板特化允许为特定类型提供独立于通用模板定义的函数实现。特化的语法如下所示：
   
   ```cpp
   template <typename T>
   void myFunction(T arg) {
       // 通用模板实现
}
   
   template <>
   void myFunction<int>(int arg) {
       // int类型的特化实现
   }
   ```
   在上述示例中，`myFunction` 是一个通用的函数模板，但通过 `template <>` 和类型 `int` 的特化声明，我们为 `int` 类型提供了特殊的函数实现。

需要注意的是，特化是一种有选择地为特定类型提供实现的机制，通常用于处理特定类型的边界情况或针对某些类型进行性能优化。在使用特化时，应慎重考虑，并确保特化实现真正符合需求，避免滥用导致代码的复杂性增加。











## 7、指针和引用的区别？

### 区别

- 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
- 指针可以有多级，引用只有一级
- 指针可以为空，引用不能为NULL且在定义时必须初始化
- 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
- sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
- 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
- 引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（，具体情况还要具体分析）。
- 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
- 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
- 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

### 参考代码

```cpp
void test(int *p)
{
　　int a=1;
　　p=&a;
　　cout<<p<<" "<<*p<<endl;
}

int main(void)
{
    int *p=NULL;
    test(p);
    if(p==NULL)
    cout<<"指针p为NULL"<<endl;
    return 0;
}
//运行结果为：
//0x22ff44 1
//指针p为NULL
```

```cpp
void testPTR(int* p) {
	int a = 12;
	p = &a;

}

void testREFF(int& p) {
	int a = 12;
	p = a;

}
void main()
{
	int a = 10;
	int* b = &a;
	testPTR(b);//改变指针指向，但是没改变指针的所指的内容
	cout << a << endl;// 10
	cout << *b << endl;// 10

	a = 10;
	testREFF(a);
	cout << a << endl;//12
}
```

在编译器看来, int a = 10; int &b = a; 等价于 int * const b = &a; 而 b = 20; 等价于 *b = 20; 自动转换为指针和自动解引用.



## 8、指针和const的用法

1. 当const修饰指针时，由于const的位置不同，它的修饰对象会有所不同。
2. `int *const p2`中`const`修饰`p2`的值,所以理解为`p2`的值不可以改变，即`p2`只能指向固定的一个变量地址，但可以通过`*p2`读写这个变量的值。顶层指针表示指针本身是一个常量
3. `int const *p1`或者`const int *p1`两种情况中const修饰`*p1`，所以理解为`*p1`的值不可以改变，即不可以给`*p1`赋值改变`p1`指向变量的值，但可以通过给p赋值不同的地址改变这个指针指向。底层指针表示指针所指向的变量是一个常量。





## 9、为什么不能把所有的函数写成内联函数?/内联函数的缺点？

内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。

所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；

另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数：

- 函数体内的代码比较长，将导致内存消耗代价
- 函数体内有循环，函数执行时间要比函数调用开销大

### 什么是内敛函数

在C++中，使用关键字"inline"可以声明一个内联函数。声明为内联函数的函数会在编译时被视为候选项，编译器会尝试将其展开，将函数体直接插入到调用点处。这样可以避免函数调用的开销，减少了函数调用的栈帧等额外开销，从而提高程序的执行效率。

### 缺点：

- 代码膨胀：内联函数会在每个调用它的地方进行代码替换，这可能导致代码膨胀。如果内联函数体非常大或者被频繁调用，会增加可执行文件的大小，可能导致缓存不命中，影响性能。
- 编译时间增加：内联函数需要在每个调用点进行代码替换，这会增加编译时间。特别是当内联函数被广泛使用时，编译时间可能会显著增加。
- 可读性降低：内联函数会将函数体嵌入到调用点，可能导致代码的可读性降低。函数体被分散在多个地方，可能会使代码难以理解和维护。



## 10、C++的多态是如何实现的？

C++的多态性，一言以蔽之就是：

在基类的函数前加上**virtual**关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。

举个例子：

```cpp
#include <iostream>
using namespace std;

class Base{
public:
	virtual void fun(){
		cout << " Base::func()" <<endl;
	}
};

class Son1 : public Base{
public:
	virtual void fun() override{
		cout << " Son1::func()" <<endl;
	}
};

class Son2 : public Base{

};

int main()
{
	Base* base = new Son1;
	base->fun();
	base = new Son2;
	base->fun();
	delete base;
	base = NULL;
	return 0;
}
// 运行结果
// Son1::func()
// Base::func()
```

例子中，Base为基类，其中的函数为虚函数。

子类1继承并重写了基类的函数，子类2继承基类但没有重写基类的函数，从结果分析子类体现了多态性，那么为什么会出现多态性，其底层的原理是什么？

### 虚表和虚基表指针

这里需要引出虚表和虚表指针的概念。

虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表，它是在编译期确定的

虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针，它是在构造函数中被初始化的

![img](assets/202205220022619.png)

![img](assets/202205220022551.png)

**上图中展示了虚表和虚表指针在基类对象和派生类对象中的模型，下面阐述实现多态的过程：**

**1**、编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址

**2**、编译器会在每个对象的前四个字节中保存一个虚表指针，即**vptr**，指向对象所属类的虚表。

在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数

**3**、所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中对虚表指针进行初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表

**4**、当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面

这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。



### 分类

C++中的多态主要通过虚函数和继承来实现。多态分为两种：编译时多态和运行时多态。

- 编译时多态：也称为静态多态或早绑定。这种多态是通过函数重载和模板来实现的。
- 运行时多态：也称为动态多态或晚绑定。这种多态是通过虚函数和继承来实现的。当基类的指针或引用指向派生类对象时，调用的虚函数将是派生类的版本，这就实现了运行时多态。



## 11、什么是纯虚函数，与虚函数的区别

- 虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。
- 纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。

纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“=0”。

既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。

一个类中如果有纯虚函数的话，称其为抽象类。抽象类不能用于实例化对象，否则会报错。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象。

举个例子：

```cpp
#include <iostream>
using namespace std;

class Base
{
public:
	virtual void fun1()
	{
		cout << "普通虚函数" << endl;
	}
	virtual void fun2() = 0;
	virtual ~Base() {}
};

class Son : public Base
{
public:
	virtual void fun2() 
	{
		cout << "子类实现的纯虚函数" << endl;
	}
};

int main()
{
	Base* b = new Son;
	b->fun1(); //普通虚函数
	b->fun2(); //子类实现的纯虚函数
	return 0;
}
```



纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在C++中，纯虚函数的声明形式如下：

```cpp
virtual void function() = 0;
```

其中，`= 0`就表示这是一个纯虚函数。

含有纯虚函数的类被称为抽象类。抽象类不能被实例化，只能作为接口使用。派生类必须实现所有的纯虚函数，否则该派生类也会变成抽象类。

纯虚函数的应用场景主要包括：

- 设计模式：例如在模板方法模式中，基类定义一个算法的骨架，而将一些步骤延迟到子类中。这些需要在子类中实现的步骤就可以声明为纯虚函数。
- 接口定义：可以创建一个只包含纯虚函数的抽象类作为接口。所有实现该接口的类都必须提供这些函数的实现。



## 12、new和malloc的区别

1、 new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持；

2、 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

3、 new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

4、 new内存分配失败时，会抛出bad_alloc异常。malloc分配内存失败时返回NULL。

5、 new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。



## 13、讲讲new的实现，其中new什么时候返回空指针，什么时候抛出异常，抛的是什么异常

`new` 是C++中用于动态分配内存的操作符，它的实现可以简单概括为两个步骤：内存分配和对象构造。

1. 内存分配：当使用 `new` 运算符来创建一个对象时，会首先分配足够大小的内存空间。如果内存分配失败，即没有足够的可用内存，那么 `new` 操作符会返回一个空指针（nullptr）。

2. 对象构造：在成功分配内存后，会调用相应类型的构造函数来构造对象。如果对象的构造过程中发生异常，`new` 操作符会抛出 `std::bad_alloc` 异常。这是因为在构造过程中可能需要执行一些分配资源、初始化等可能导致失败的操作。

下面是一个示例：

```cpp
try {
    MyClass* obj = new MyClass; // 尝试动态分配内存并构造对象
    // ...
} catch (const std::bad_alloc& e) {
    // 内存分配失败，处理异常
    // ...
}
```

需要注意的是，虽然 `new` 可能会返回空指针或抛出异常，但在现代的C++编译器中，通常对于内置类型的动态分配内存，如 `int`、`float` 等，不会抛出异常，而是直接返回空指针。这是因为内置类型的构造过程不存在可能导致失败的操作。

此外，为了防止内存泄漏，每次使用 `new` 分配内存后，应该在不再使用时通过 `delete` 或 `delete[]` 运算符释放相应的内存空间。



## 14、malloc线程安全吗，多线程malloc系统怎么设计

`malloc` 函数本身并不是线程安全的。在多线程环境下，多个线程同时调用 `malloc` 可能会导致竞争条件和内存错误。

为了在多线程环境下安全地使用 `malloc`，可以采取以下一些策略：

1. 使用互斥锁：在使用 `malloc` 前后通过互斥锁（例如 `std::mutex`）来保护共享资源，确保同一时间只有一个线程调用 `malloc`。

2. 使用线程局部存储（Thread Local Storage, TLS）：将 `malloc` 的调用限定在每个线程的私有内存中。可以使用线程特定数据（Thread-Specific Data, TSD）或者平台提供的机制，如 `pthread_key_create()` 和 `pthread_setspecific()` 来实现线程局部存储。

3. 使用内存池（Memory Pool）：在多线程场景下，可以预先分配一块较大的内存作为内存池，并由每个线程从内存池中动态分配内存。这种方式可以减少对全局内存分配器的竞争，提高性能。

需要注意的是，以上方法都需要考虑到线程安全和性能之间的平衡，以及在释放内存时的处理。另外，C++ 中也提供了更好的内存管理方式，如使用 `new` 和 `delete` 运算符、智能指针等，可以更好地管理内存资源，并且在多线程环境下具有更好的线程安全性。





## 15、C++ map是线程安全的吗，怎么保证map线程安全

在标准C++中，`std::map` 并没有被设计为线程安全的容器。这意味着在多个线程同时读取和修改 `std::map` 对象时，可能会产生竞态条件（race condition）和数据不一致的问题。

如果你需要在多线程环境下使用 `std::map` 并保证线程安全，可以考虑以下两种方式：

1. 使用互斥锁（Mutex）：在每次对 `std::map` 进行读取或修改操作之前，使用互斥锁进行同步，即确保同一时间只有一个线程能够访问和修改 `std::map`。这样可以避免并发访问导致的数据竞争问题。具体实现可借助 `std::mutex` 和 `std::lock_guard` 等类来管理互斥锁的加锁和解锁操作。

2. 使用线程安全的替代容器：C++17 引入了一些线程安全的并发容器，例如 `std::map` 的线程安全替代品是 `std::map<std::shared_mutex>` 或 `std::map<std::shared_timed_mutex>`。它们使用了共享-排他锁（Shared-Exclusive Locking）机制，允许多个线程并发地读取容器，但只允许一个线程进行写入操作。通过使用这些线程安全的容器，可以避免显式地添加互斥锁来保护容器的并发访问。

无论选择哪种方式，都需要根据具体的使用场景和需求来确定最合适的保证线程安全的方法。注意，在进行并发编程时，除了保证数据结构本身的线程安全性外，还需要注意其他与多线程相关的问题，如原子操作、内存可见性等。







## 16、const关键字的作用有哪些?

1. 阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
2. 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
3. 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
4. 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数；
5. 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。
6. const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；
7. 非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；
8. 一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此const对象只能调用const成员函数。
9. const类型变量可以通过类型转换符const_cast将const类型转换为非const类型；
10. const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；
11. 对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。





## 17、面试题：std::unique_lock和std::lock_guard

`std::unique_lock`和`std::lock_guard`都是C++11引入的，用于管理互斥锁定。它们的设计意图是提供RAII（Resource Acquisition Is Initialization）风格的锁管理，以确保在作用域结束或异常发生时能自动释放锁，避免资源泄漏和死锁。

**std::lock_guard:**
`std::lock_guard`是一种简单的RAII锁保管对象，主要用于保护某个代码段。当创建`std::lock_guard`对象时，它会尝试立即获取互斥锁。如果成功，`std::lock_guard`将拥有该锁，否则代码将阻塞，直至锁可用。当`std::lock_guard`对象离开其作用域时，其析构函数会自动解锁。

基本用法：
```cpp
{
  std::lock_guard<std::mutex> lock(my_mutex);
  // 临界区（保护的代码段）
} // 锁在lock离开作用域时自动解锁
```

注意：
1. `std::lock_guard`不提供手动锁定和解锁功能。
2. `std::lock_guard`不支持所有权转移。

**std::unique_lock:**
`std::unique_lock`提供了比`std::lock_guard`更为灵活的锁保管，支持更多操作。与`std::lock_guard` 类似，`std::unique_lock`也是一个RAII锁保管对象。但它提供了更多的功能，如延迟锁定、手动锁定、解锁、尝试锁定以及所有权转移。

基本用法：
```cpp
{
  std::unique_lock<std::mutex> lock(my_mutex);
  // 临界区（保护的代码段）
} // 锁在lock离开作用域时自动解锁
```

延迟锁定，手动锁定和解锁的示例：
```cpp
{
  std::unique_lock<std::mutex> lock(my_mutex, std::defer_lock);
  // 延迟锁定
  lock.lock();
  // 临界区
  lock.unlock();
  // 在解锁后的操作
}
```
注意：
1. `std::unique_lock`资源开销稍高于`std::lock_guard`。

总结如下:
- 对于简单的用例，`std::lock_guard`是首选，因为它非常简单且轻量。
- 对于需要手动锁定/解锁、尝试锁定或延迟锁定等高级功能的用例，应使用`std::unique_lock`。

你应该根据程序的需求和目标来选择使用哪个。在常规情况下，`std::lock_guard`通常足够使用，但对于需要更多控制的情况，应以灵活性和功能为优先选择`std::unique_lock`。





## 20、对面向对象的理解

C++面向对象编程就是把一切事物都变成一个个对象，用属性和方法来描述对象的信息，比如定义一个猫对象，猫的眼睛、毛发、嘴巴就可以定义为猫对象的属性，猫的叫声和走路就可以定义为猫对象的方法。

用对象的方式编程，不仅方便了程序员，也使得代码的可复用性、可维护性变好。

C++面向对象的三大特性是封装、继承、多态。

- **封装**：封装是将数据（变量）和操作数据的函数组合在一起形成一个"对象"，并隐藏了对象的内部细节。这可以防止外部代码直接访问对象的内部表示。
- **继承**：继承是从现有类派生出新类的过程。新类包含了现有类的所有特性，并可以添加自己的新特性。这有助于代码重用和减少复杂性。
- **多态**：多态是指允许使用一个接口来表示不同的类型。在C++中，多态可以通过虚函数实现，使得不同的对象可以以自己的方式响应相同的消息。



## 22、普通的函数和成员函数的区别？

- 普通函数是在类的外部定义的，而成员函数是在类的内部定义的。
- 普通函数不能直接访问类的私有（private）和保护（protected）成员，而成员函数可以访问类的所有成员，包括私有和保护成员。
- 普通函数可以直接调用，而成员函数需要通过类的对象来调用。
- 成员函数有一个特殊的指针this，它指向调用该成员函数的对象。普通函数没有这个指针。



## 24、this 指针是干嘛的？

this 指针是指向当前对象的地址。this指针主要用于在类的成员函数中访问当前对象的成员变量和成员函数。

当一个对象调用自己的成员函数时，编译器会隐式地将对象的地址传递给成员函数，作为一个隐藏的参数，这个隐藏的参数就是this指针。通过this指针，成员函数可以访问和操作当前对象的成员变量和成员函数。

this指针只能在非静态成员函数中使用，因为静态成员函数没有this指针，它们不属于任何具体的对象





## 26、static关键字的作用？

static:静态变量声明，分为局部静态变量，全局静态变量，类静态成员变量。也可修饰类成员函数。有以下几类：

- 局部静态变量：存储在静态存储区，程序运行期间只被初始化一次，作用域仍然为局部作用域，在变量定义的函数或语句块中有效，程序结束时由操作系统回收资源。
- 全局静态变量：存储在静态存储区，静态存储区中的资源在程序运行期间会一直存在，直到程序结束由系统回收。未初始化的变量会默认为0，作用域在声明他的文件中有效。
- 类静态成员变量：被类的所有对象共享，包括子对象。必须在类外初始化，不可以在构造函数内进行初始化。
- 类静态成员函数：所有对象共享该函数，不含this指针，不可使用类中非静态成员。





