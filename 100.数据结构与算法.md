## 1、哈希表的原理

哈希表（Hash Table，也叫散列表），是根据关键码值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。

### 哈希函数

```
H(keyi)=Loc(i)
```

记录存储位置与关键字之间存在的对应关系

### 冲突解决

现实中的哈希函数不是完美的，当两个不同的输入值对应一个输出值时，就会产生“冲突”，

**冲突**  不同的关键码映射到同一个散列地址，

```
key1!=key2, 但是H(key1)=H(key2)
```

在散列查找方法中，冲突是不可能避免的，只能进可能减少



常见的冲突解决方法有开放定址法，链地址法，建立公共溢出区等。实际的哈希表实现中，使用最多的是链地址法

#### 链地址法

链地址法的基本思想是，为每个 Hash 值建立一个单链表，当发生冲突时，将记录插入到链表中。

![1691494680900](assets/1691494680900.png)

![1691494750596](assets/1691494750596.png)

![1691494774979](assets/1691494774979.png)



## 2、如何判断一个哈希表的优劣

判断一个哈希表的优劣可以从以下几个方面考虑：

1. 冲突率：冲突率是指哈希表中发生冲突的键值对数量与总键值对数量的比例。冲突率越低，说明哈希表的性能越好。可以通过计算实际冲突数与总插入数的比例来评估冲突率。低冲突率可以减少查找时间，提高哈希表的效率。

2. 负载因子：负载因子是指哈希表中实际存储的键值对数量与哈希表大小的比例。负载因子越低，哈希表的性能越好。当负载因子过高时，冲突的概率会增加，导致查找、插入和删除的效率下降。一般来说，负载因子的合理范围是0.7到0.8之间。

3. 哈希函数的性能：哈希函数的设计对哈希表的性能有很大影响。一个好的哈希函数应该能够将键均匀地映射到哈希表的不同位置，减少冲突的概率。同时，哈希函数的计算速度应该快，以提高哈希表的操作效率。

4. 冲突解决方法：不同的冲突解决方法对哈希表的性能有影响。常见的冲突解决方法包括链地址法、开放地址法、再哈希法等。选择合适的冲突解决方法取决于具体的应用场景和需求。

5. 存储空间利用率：好的哈希表应该能够充分利用存储空间。过大的存储空间会浪费内存资源，而过小的存储空间会导致冲突率增加。因此，需要根据实际需求选择适当的哈希表大小。

6. 插入、查找和删除操作的效率：好的哈希表应该能够在常数时间内完成插入、查找和删除操作。这要求哈希函数的计算速度快，冲突率低，冲突解决方法高效。

综合考虑以上因素，可以评估一个哈希表的优劣。在实际应用中，根据具体的数据集和操作需求，选择合适的哈希函数、冲突解决方法和哈希表大小，进行性能测试和比较，以确定最佳的哈希表实现。





## 3、哈希表的时间复杂度为什么是O（1）？

哈希表的时间复杂度为O(1)是因为它使用了一种叫做哈希函数的方法来直接计算出数据应该存储在哪个位置，而不需要逐个检查每个位置。这就像是你有一个巨大的文件柜，每个抽屉都有一个唯一的编号，你可以直接通过编号找到你需要的文件，而不需要从第一个抽屉开始逐个查找。

当你插入、删除或查找一个元素时，哈希表首先使用哈希函数计算出元素的哈希值，然后使用这个哈希值作为索引直接访问到数组中的相应位置。因此，这些操作的时间复杂度都是O(1)。









## 5、平衡二叉树结构是怎么样的？

平衡二叉树是在二叉搜索树的基础上，平衡二叉树还需要满足如下条件:

- 左右两个子树的高度差（平衡因子）的绝对值不超过1
- 左右两个子树都是一棵平衡二叉树

![图片](assets/640-1693736419437.png)

分析：

- 图一是一个平衡二叉树，它满足平衡二叉树的定义。
- 图二不是平衡二叉树，其原因并不是不满足平衡因子的条件，而是因为它不满足二叉搜索树的构成条件，这提醒我们平衡二叉树首先要是一棵二叉搜索树。
- 图三满足平衡二叉树的构成条件。
- 图 4 中的节点 (8) 平衡因子为 3，不满足平衡二叉树的要求。









## 8、堆是什么？

堆是一颗**完全二叉树**，这样实现的堆也被称为**二叉堆**。堆中节点的值都大于等于（或小于等于）其子节点的值，堆中如果节点的值都大于等于其子节点的值，我们把它称为**大顶堆**，如果都小于等于其子节点的值，我们将其称为**小顶堆**。

下图中，1，2 是大顶堆，3 是小顶堆， 4 不是堆（不是完全二叉树）

![图片](assets/640-1693737610983.png)

## 10、栈和队列，举个使用场景例子

![图片](assets/640-1693737611039.png)

- 栈是一种后进先出（LIFO）的数据结构，**函数的调用和返回往往使用栈来管理函数调用的顺序**。
- 队列是一种先进先出（FIFO）的数据结构，类似于排队等待的队伍，先到的人会先被服务。队列常用于需要先进先出的场景，例如：**在网络通信或磁盘读写等场景中，使用队列来管理数据的接收和发送顺序，以平衡生产者和消费者之间的速度差异**。